res.text(); document.getElementById('results').innerHTML = html; }); </script> </body> </html> [Ends here - chunk-committer.html] [Starts here - chunk-committer.php] <?php // chunk-committer.php require_once 'config.php'; header('Content-Type: text/html'); // ====== Get POSTed JSON ====== $data = json_decode(file_get_contents('php://input'), true); $text = $data['text'] ?? ''; $chunkSize = intval($data['chunkSize'] ?? 2000); $maxChunks = intval($data['maxChunks'] ?? 5); $commitPrefix = trim($data['commitPrefix'] ?? 'Chunk Upload'); $filenameBase = trim($data['filenameBase'] ?? 'doc-part'); $token = trim($data['token'] ?? ''); if (!$text || !$token) { echo "<p style='color: red;'>‚ùå Missing text or token.</p>"; exit; } // ====== Chunk the text ====== $words = preg_split('/\s+/', $text); $chunks = array_chunk($words, $chunkSize); $totalChunks = min(count($chunks), $maxChunks); echo "<h2>üöÄ Starting Commit of $totalChunks Chunks</h2><ul>"; for ($i = 0; $i < $totalChunks; $i++) { $chunkText = implode(' ', $chunks[$i]); $filename = sprintf('%s-%02d.md', $filenameBase, $i + 1); $commitMessage = sprintf('%s #%d', $commitPrefix, $i + 1); $payload = json_encode([ 'filename' => $filename, 'content' => $chunkText, 'commit_message' => $commitMessage ]); // ====== cURL POST to ai-commit-handler.php ====== $ch = curl_init('https://blackbox.world/chatgpt/nexus-github-repo/ai-commit-handler.php'); // $ch = curl_init('ai-commit-handler.php'); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_POSTFIELDS, $payload); curl_setopt($ch, CURLOPT_HTTPHEADER, [ 'Content-Type: application/json', 'X-AI-Token: ' . $token ]); $response = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); curl_close($ch); $result = json_decode($response, true); // DEBUG DUMP if JSON fails if ($result === null) { echo "<li>‚ùå <strong>$filename</strong> failed: Invalid JSON response.<br><code>$response</code></li>"; continue; } if ($result['success'] ?? false) { echo "<li>‚úÖ <strong>$filename</strong> committed<br>üìé <a href='{$result['commit_url']}' target='_blank'>View Commit</a></li>"; } else { $error = htmlspecialchars($result['error'] ?? 'Unknown error'); echo "<li>‚ùå <strong>$filename</strong> failed: $error</li>"; } flush(); // Send output incrementally } echo "</ul><p>üß† Done. Check GitHub repo for updates.</p>"; [Ends here - chunk-committer.php] [Starts here - chunk-simulator.html] <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8" /> <title>Chunk Uploader & Formatter</title> <style> body { font-family: sans-serif; max-width: 800px; margin: 2em auto; } textarea, input { width: 100%; margin-top: 1em; padding: 0.5em; } button { margin-top: 1em; padding: 0.75em 1.5em; } pre { background: #f4f4f4; padding: 1em; border-radius: 5px; white-space: pre-wrap; } </style> </head> <body> <h1>Chunk Uploader & Formatter</h1> <form id="chunkForm"> <label>Paste your full text (e.g. Google Doc export):</label> <textarea id="fullText" rows="15"></textarea> <label>Chunk size (words per chunk):</label> <input type="number" id="chunkSize" value="300" /> <button type="submit">Chunk & Simulate</button> </form> <div id="results"></div> <script> document.getElementById('chunkForm').addEventListener('submit', async function(e) { e.preventDefault(); const fullText = document.getElementById('fullText').value; const chunkSize = parseInt(document.getElementById('chunkSize').value); const res = await fetch('chunk-simulator.php', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ fullText, chunkSize }) }); const data = await res.text(); document.getElementById('results').innerHTML = data; }); </script> </body> </html> [Ends here - chunk-simulator.html] [Starts here - chunk-simulator.php] <?php // chunk-simulator.php header('Content-Type: text/html'); $input = json_decode(file_get_contents('php://input'), true); $text = $input['fullText'] ?? ''; $chunkSize = intval($input['chunkSize'] ?? 300); // Split text into words $words = preg_split('/\s+/', $text); $chunks = array_chunk($words, $chunkSize); echo "<h2>üß† Simulated AI Responses per Chunk</h2>"; foreach ($chunks as $index => $chunkWords) { $chunkText = implode(' ', $chunkWords); $summary = substr($chunkText, 0, 150) . (strlen($chunkText) > 150 ? '...' : ''); $hash = hash('sha256', $chunkText); $timestamp = date('Y-m-d H:i:s'); echo "<pre><strong>Chunk #" . ($index + 1) . "</strong>\n"; echo "Words: " . count($chunkWords) . "\n"; echo "Timestamp: $timestamp\n"; echo "SHA256: $hash\n"; echo "\nMock Summary:\n"; echo $summary . "\n</pre>"; } [Ends here - chunk-simulator.php] [Starts here - config.php] <?php // config.php require_once __DIR__ . '/load_env.php'; define('GITHUB_TOKEN', getenv('GITHUB_TOKEN')); define('GITHUB_REPO', 'nexus'); define('GITHUB_OWNER', 'blackbox-world'); define('AI_COMMIT_SECRET', getenv('AI_COMMIT_SECRET')); [Ends here - config.php] [Starts here - env-test.php] <?php require_once 'load_env.php'; echo "<pre>"; echo "GITHUB_TOKEN: " . getenv('GITHUB_TOKEN') . "\n"; echo "AI_COMMIT_SECRET: " . getenv('AI_COMMIT_SECRET') . "\n"; echo "</pre>"; [Ends here - env-test.php] [Starts here - generate-php.php] <?php // generate-php.php require_once 'openai-helper.php'; $prompt = "Write a simple PHP function that calculates the factorial of a number using recursion."; $response = openai_generate_code($prompt); header('Content-Type: text/plain'); echo "=== Prompt ===\n$prompt\n\n=== Response ===\n$response\n"; [Ends here - generate-php.php] [Starts here - github-helper.php] <?php // github-helper.php require_once 'config.php'; // Load GITHUB_TOKEN $token = GITHUB_TOKEN; // Now works perfectly function github_get_file_info($owner, $repo, $path, $branch = 'main') { $token = getenv('GITHUB_TOKEN'); $url = "https://api.github.com/repos/$owner/$repo/contents/$path?ref=$branch"; $ch = curl_init($url); curl_setopt($ch, CURLOPT_HTTPHEADER, [ "User-Agent: blackbox-world-agent", "Authorization: token $token" ]); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $response = curl_exec($ch); $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE); curl_close($ch); if ($http_code === 200) { $data = json_decode($response, true); return [ 'sha' => $data['sha'] ?? null, 'content' => base64_decode($data['content'] ?? ''), ]; } elseif ($http_code === 404) { // File does not exist yet return null; } else { return null; } } function github_update_file($owner, $repo, $path, $content, $commit_message, $branch = 'main') { $token = getenv('GITHUB_TOKEN'); $api_url = "https://api.github.com/repos/$owner/$repo/contents/$path"; $file_info = github_get_file_info($owner, $repo, $path, $branch); $sha = $file_info['sha'] ?? null; $payload = [ 'message' => $commit_message, 'content' => base64_encode($content), 'branch' => $branch, ]; if ($sha) { $payload['sha'] = $sha; } $ch = curl_init($api_url); curl_setopt($ch, CURLOPT_HTTPHEADER, [ "User-Agent: blackbox-world-agent", "Authorization: token $token", "Content-Type: application/json" ]); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT'); curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($payload)); $response = curl_exec($ch); $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE); curl_close($ch); if (in_array($http_code, [200, 201])) { return ['success' => true, 'data' => json_decode($response, true)]; } return ['success' => false, 'error' => "GitHub API error (HTTP $http_code): $response"]; } [Ends here - github-helper.php] [Starts here - hash-file.php] <?php // hash-file.php // Computes SHA‚Äë256 of a .md or code file, optionally up to <!-- HASH-END --> $target = $_GET['file'] ?? ''; if (!$target || !file_exists($target)) { echo "File not found or not specified."; exit; } $content = file_get_contents($target); $cutoff = '<!-- HASH‚ÄëEND -->'; if (strpos($content, $cutoff) !== false) { $content = substr($content, 0, strpos($content, $cutoff) + strlen($cutoff)); } $hash = hash('sha256', $content); $shaFile = $target . '.sha256.txt'; file_put_contents($shaFile, $hash . ' ' . $target); echo "<pre>SHA‚Äë256 for $target:\n$hash\nSaved to $shaFile</pre>"; [Ends here - hash-file.php] [Starts here - load_env.php] <?php // load_env.php - Simple .env loader for PHP (no external packages) // Get full path to .env file $envPath = __DIR__ . '/.env'; if (file_exists($envPath)) { $lines = file($envPath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES); foreach ($lines as $line) { // Skip comments if (strpos(trim($line), '#') === 0) continue; // Split into key=value list($key, $value) = explode('=', $line, 2); // Remove quotes and whitespace $key = trim($key); $value = trim($value, " \t\n\r\0\x0B\"'"); // Set environment variable putenv("$key=$value"); $_ENV[$key] = $value; $_SERVER[$key] = $value; } } [Ends here - load_env.php] [Starts here - openai-helper.php] <?php // openai-helper.php require_once 'config.php'; function openai_generate_code($prompt, $temperature = 0.7, $max_tokens = 500) { $apiKey = getenv('OPENAI_API_KEY'); $url = 'https://api.openai.com/v1/chat/completions'; $data = [ 'model' => 'gpt-4', 'messages' => [ ['role' => 'system', 'content' => 'You are a helpful AI that writes clean PHP or Markdown files.'], ['role' => 'user', 'content' => $prompt] ], 'temperature' => $temperature, 'max_tokens' => $max_tokens ]; $headers = [ 'Content-Type: application/json', 'Authorization: Bearer ' . $apiKey ]; $ch = curl_init($url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data)); curl_setopt($ch, CURLOPT_HTTPHEADER, $headers); $response = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); curl_close($ch); if ($httpCode === 200) { $result = json_decode($response, true); return $result['choices'][0]['message']['content'] ?? ''; } else { return "Error from OpenAI (HTTP $httpCode): $response"; } } [Ends here - openai-helper.php] [Starts here - robots.txt] User-agent: * Disallow: / [Ends here - robots.txt] [Starts here - test-uploader.html] <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8" /> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>AI Commit Test Uploader</title> <style> body { font-family: Arial, sans-serif; max-width: 700px; margin: 2em auto; } label { display: block; margin-top: 1em; } textarea { width: 100%; height: 300px; font-family: monospace; font-size: 14px; } input[type=text], textarea { padding: 0.5em; border: 1px solid #ccc; border-radius: 4px; } button { margin-top: 1em; padding: 0.75em 1.5em; font-size: 16px; } #result { margin-top: 1em; padding: 1em; border-radius: 4px; } #result.success { background: #d4edda; color: #155724; } #result.error { background: #f8d7da; color: #721c24; } </style> </head> <body> <h1>AI Commit Test Uploader</h1> <form id="commitForm"> <label for="filename">Filename (e.g. build.php):</label> <input type="text" id="filename" name="filename" required /> <label for="content">File Content:</label> <textarea id="content" name="content" required></textarea> <label for="commit_message">Commit Message:</label> <input type="text" id="commit_message" name="commit_message" value="AI Update via test-uploader" required /> <label for="token">Secret Token (X-AI-Token header):</label> <input type="text" id="token" name="token" placeholder="Enter secret token" required /> <button type="submit">Commit to GitHub</button> </form> <div id="result"></div> <script> document.getElementById('commitForm').addEventListener('submit', async function(e) { e.preventDefault(); const filename = document.getElementById('filename').value.trim(); const content = document.getElementById('content').value; const commit_message = document.getElementById('commit_message').value.trim(); const token = document.getElementById('token').value.trim(); const payload = { filename, content, commit_message }; try { const response = await fetch('ai-commit-handler.php', { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-AI-Token': token }, body: JSON.stringify(payload) }); const data = await response.json(); const resultDiv = document.getElementById('result'); if (data.success) { resultDiv.className = 'success'; resultDiv.innerHTML = ‚úÖ File <strong>${data.file}</strong> committed successfully!<br> Commit URL: <a href="${data.commit_url}" target="_blank">${data.commit_url}</a><br> SHA: ${data.sha} ; } else { resultDiv.className = 'error'; resultDiv.textContent = ‚ùå Commit failed: ${data.error || 'Unknown error'}; } } catch (err) { const resultDiv = document.getElementById('result'); resultDiv.className = 'error'; resultDiv.textContent = '‚ùå Request error: ' + err.message; } }); </script> </body> </html> [Ends here - test-uploader.html] [Starts here - verify_sha256.php] <?php /** * verify_sha256.php * * Verifies a Markdown (.md) file against its .sha256.txt hash. * Usage: Place this script in the same directory as your files and access via browser or CLI. */ function verify_sha256($md_file, $hash_file) { if (!file_exists($md_file)) { return "Markdown file not found: $md_file"; } if (!file_exists($hash_file)) { return "Hash file not found: $hash_file"; } $computed_hash = hash_file('sha256', $md_file); $expected_hash = trim(file_get_contents($hash_file)); // Handle "hash filename" format $expected_hash = explode(' ', $expected_hash)[0]; if ($computed_hash === $expected_hash) { return "‚úÖ Verification successful: $md_file matches $hash_file"; } else { return "‚ùå Verification failed: Hash mismatch\nExpected: $expected_hash\nGot: $computed_hash"; } } // Example usage (can also pass via ?md=your.md&hash=your.md.sha256.txt) $md_file = isset($_GET['md']) ? $_GET['md'] : 'stop.ponder.smile.md'; $hash_file = isset($_GET['hash']) ? $_GET['hash'] : 'stop.ponder.smile.md.sha256.txt'; echo "<pre>" . verify_sha256($md_file, $hash_file) . "</pre>"; ?> [Ends here - verify_sha256.php] [Ends here] Does this help or not? ChatGPT said: Thanks ‚Äî this full dump is incredibly helpful. It confirms a lot, and shows that your system is already quite solid. Here's what this setup reveals, what it's doing well, and what could be enhanced further (if you're open to pushing this system to next-level flexibility and control): ‚úÖ Quick Summary of What You‚Äôve Built You‚Äôve created a private, token-protected, IP-locked AI-to-GitHub commit gateway with: A user-friendly HTML/JS front-end to upload, split, and commit chunks of text. A secure PHP backend (ai-commit-handler.php) that: Checks IP whitelist Verifies token against multiple secrets Commits Markdown to GitHub via github-helper.php Logs all activity to access.log Tools to simulate chunking, hash files, test commits, and generate code using OpenAI. All modular. All local. All within /ngr/. This is a mini CI/CD + AI-assisted knowledge base pipeline. Super cool. üîç Observations + Notes üîê 1. Security is solid and layered IP whitelist: ‚úÖ Only whitelisted IPs can hit commit endpoint. Token check: ‚úÖ Supports multiple AI_COMMIT_SECRET* values in .env. Token required for commit via chunk-committer.php: ‚úÖ Optional idea: You could add rate limiting or request count logging (e.g., per IP per day) in the log_access() function to prevent abuse, especially if made more public-facing later. üß† 2. Chunking logic is reliable and readable chunk-committer.php breaks input text by words using preg_split('/\s+/'), which is perfect. Chunk limit (maxChunks) avoids accidental flooding of the GitHub repo. Suggestions (Optional): Show word count total and average words per chunk on the page. Add a checkbox for: Trim whitespace, Remove repeated blank lines, or Preserve original newlines. üìÅ 3. Commits are deduplicated using SHA Your SHA hash tracking in access.log lets you see what's already been committed. Nice. But right now, commits will still proceed even if the same file (same name/content) is submitted again ‚Äî GitHub will just overwrite. Optionally, you could: Check SHA of current file from GitHub (github_get_file_info()) and skip commit if unchanged. Or log "Duplicate content, skipping" in access.log. üß™ 4. Test and simulate tools help a ton chunk-simulator.html + .php: Great for local-only testing of chunking and SHA. test-uploader.html: Manual one-file uploader ‚Äî useful for debugging or edge cases. generate-php.php: Good minimal OpenAI codegen example. Nice touch with: <!-- HASH‚ÄëEND --> To allow content hashing up to a certain point. That can be used to ignore trailing metadata or AI explanations in the future. üöÄ Feature Ideas (based on where you‚Äôre going) 1. Auto-create folders based on date or title e.g., Instead of all files being in root, auto-prefix with 2025-09-26-Friday/ Helps organize by session, context, or document origin. You‚Äôre already doing this manually (2025-09-26-Friday-03/doc-part-04.md), so it could be automated by adding: $folder = date('Y-m-d') . '-Friday'; // Or passed via POST $filename = "$folder/"